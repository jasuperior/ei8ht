{"version":3,"file":"lib.js","sources":["../src/model/unit.model.ts","../src/api/helpers/identity.ts","../src/api/domain/polytype.ts","../src/api/helpers/transformers.ts","../src/api/adapters/fromAsyncMethod.ts","../src/api/adapters/fromAsyncProcedure.ts","../src/api/adapters/fromSyncMethod.ts","../src/api/adapters/fromSyncProcedure.ts","../src/api/adapters/fromKey.ts","../src/api/factories/createUnit.ts","../src/api/domain/constants.ts","../src/api/units/Html/helpers.ts","../src/api/units/Html/htmlEvents.ts","../src/api/units/Html/htmlTags.ts","../src/api/units/Html/Html.ts"],"sourcesContent":["import { hasInstance } from \"../api/domain/constants\";\nimport { Polytype } from \"../api/domain/polytype\";\nimport { Scope, StringRecord } from \"./domain.model\";\n\n/**\n * @description\n * the type of a unit. This is used to determine if the unit is sync or async.\n */\nexport enum UnitType {\n    SYNC = \"sync\",\n    ASYNC = \"async\",\n}\n/**\n * @description\n * the state of an async unit. This is used to determine if the unit is\n * pending, resolved, or rejected.\n */\nexport enum UnitState {\n    PENDING = \"pending\",\n    RESOLVED = \"resolved\",\n    REJECTED = \"rejected\",\n}\n\n/**\n * @description\n * the kind of a unit. This is used to determine if the unit is procedural or\n * pure function.\n */\nexport enum UnitKind {\n    METHODIC = \"methodic\",\n    PROCEDURAL = \"procedural\",\n}\n\n/**\n * @description\n * the output of a unit after its next method is called.\n * @template T the type of the unit's scope.\n */\nexport type UnitFrame<T = any> = {\n    value: T;\n    done: boolean;\n};\n\nexport type ParentScope<\n    Parent = unknown,\n    Initial = unknown,\n    Current = unknown\n> = Parent & Initial & Current;\nexport namespace ParentScope {\n    export type Of<U extends Unit> = U extends Unit<infer P, infer I, infer C>\n        ? ParentScope<P, I, C>\n        : never;\n}\n\nexport type UnitScope<\n    Parent extends ParentScope = unknown,\n    Initial extends Scope = any,\n    Current extends Scope = any\n> = Polytype<Initial, Parent, Current> & ParentScope<Parent, Initial, Current>;\n// &\n// [parent: Parent, initial: Initial, current: Current];\n\n// ---------------- Unit Methods  ---------------- //\nexport type AsyncWorkMethod<\n    Parent extends Scope = any,\n    Initial extends Scope = any,\n    Current extends Scope = any\n> = (\n    input: ParentScope<Parent, Initial, Current>,\n    branches: Unit<ParentScope<Parent, Initial, Current>, any, any>[],\n    self: AsyncUnit<Parent, Initial, Current>\n) => PromiseLike<Current>;\n\nexport type SyncWorkMethod<\n    Parent extends Scope = any,\n    Initial extends Scope = any,\n    Current extends Scope = any\n> = (\n    input: ParentScope<Parent, Initial, Current>,\n    branches: Unit<ParentScope<Parent, Initial, Current>, any, any>[],\n    self: SyncUnit<Parent, Initial, Current>\n) => Current;\n\n/**\n * @description\n * A work method is a function that is used to define the behavior of a unit.\n * It can be either an async or sync method.\n */\nexport type WorkMethod<\n    Parent extends Scope = any,\n    Initial extends Scope = any,\n    Current extends Scope = any\n> =\n    | AsyncWorkMethod<Parent, Initial, Current>\n    | SyncWorkMethod<Parent, Initial, Current>;\n\n// ---------------- Unit Procedures  ---------------- //\nexport type AsyncWorkProcedure<\n    Parent extends Scope = any,\n    Initial extends Scope = any,\n    Current extends Scope = any\n> = (\n    input: ParentScope<Parent, Initial, Current>,\n    branches: Unit<ParentScope<Parent, Initial, Current>, any, any>[],\n    self: AsyncUnit<Parent, Initial, Current>\n) => AsyncGenerator<Current | void, Current | void, Parent>;\n\nexport type SyncWorkProcedure<\n    Parent extends Scope = any,\n    Initial extends Scope = any,\n    Current extends Scope = any\n> = (\n    input: ParentScope<Parent, Initial, Current>,\n    branches: Unit<ParentScope<Parent, Initial, Current>, any, any>[],\n    self: SyncUnit<Parent, Initial, Current>\n) => Generator<Current | void, Current | void, Parent>;\n\n/**\n * @description\n * A work procedure is a generator function that is used to define the behavior\n * of a unit. It can be either an async or sync procedure.\n */\nexport type WorkProcedure<\n    Parent extends Scope = any,\n    Initial extends Scope = any,\n    Current extends Scope = any\n> =\n    | AsyncWorkProcedure<Parent, Initial, Current>\n    | SyncWorkProcedure<Parent, Initial, Current>;\n\nexport type SyncWork<\n    P extends Scope = any,\n    I extends Scope = P,\n    C extends Scope = I\n> =\n    | SyncWorkMethod<ParentScope<unknown, unknown, P>, I, C>\n    | SyncWorkProcedure<ParentScope<unknown, unknown, P>, I, C>;\n\nexport type AsyncWork<\n    P extends Scope = any,\n    I extends Scope = P,\n    C extends Scope = I\n> =\n    | AsyncWorkMethod<ParentScope<unknown, unknown, P>, I, C>\n    | AsyncWorkProcedure<ParentScope<unknown, unknown, P>, I, C>;\n\n/**\n * @description\n * Work is a function that is used to define the behavior of a unit.\n * It can be either an async or sync method or procedure.\n */\nexport type Work<\n    Parent extends Scope = any,\n    Initial extends Scope = Parent,\n    Current extends Scope = Initial\n> = SyncWork<Parent, Initial, Current> | AsyncWork<Parent, Initial, Current>;\n\nexport type WorkOf<U extends Unit> = U[\"work\"];\nexport namespace Work {\n    /**\n     * @description\n     * An order is a synchronous method of work.\n     * It is a function that returns or yields a value.\n     * It can be used to define a unit that repeats one or many order(s).\n     * @see SyncWork\n     * @see SyncWorkMethod\n     * @see SyncWorkProcedure\n     */\n    export type Order<\n        Parent extends Scope = any,\n        Initial extends Scope = Parent,\n        Current extends Scope = Initial\n    > = SyncWork<Parent, Initial, Current>;\n\n    /**\n     * @description\n     * An objective is an asynchronous method of work.\n     * It is a function that returns or yields a promise.\n     * It can be used to define a unit that repeats one or many objective(s).\n     * @see AsyncWork\n     * @see AsyncWorkMethod\n     * @see AsyncWorkProcedure\n     */\n    export type Objective<\n        Parent extends Scope = any,\n        Initial extends Scope = Parent,\n        Current extends Scope = Initial\n    > = AsyncWork<Parent, Initial, Current>;\n\n    /**\n     * @description\n     * a method is a function that returns a single value or promise of a value.\n     * It can be used to define a unit that repeats a single method.\n     * It can be either an async or sync.\n     * @see WorkMethod\n     * @see AsyncWorkMethod\n     * @see SyncWorkMethod\n     */\n    export type Method<\n        Parent extends Scope = any,\n        Initial extends Scope = Parent,\n        Current extends Scope = Initial\n    > = WorkMethod<Parent, Initial, Current>;\n\n    /**\n     * @description\n     * A procedure is a generator function that returns or yields a value or promise of a value.\n     * It can be used to define a unit that repeats a single procedure.\n     * It can be either an async or sync.\n     * @see WorkProcedure\n     * @see AsyncWorkProcedure\n     * @see SyncWorkProcedure\n     */\n    export type Procedure<\n        Parent extends Scope = any,\n        Initial extends Scope = Parent,\n        Current extends Scope = Initial\n    > = WorkProcedure<Parent, Initial, Current>;\n\n    /**\n     * @description\n     * A step is a synchronous method of work.\n     * It is a function that returns a value.\n     * It can be used to define a unit that repeats a single step.\n     * @see SyncWorkMethod\n     * @see WorkMethod\n     */\n    export type Step<\n        Parent extends Scope = any,\n        Initial extends Scope = Parent,\n        Current extends Scope = Initial\n    > = SyncWorkMethod<Parent, Initial, Current>;\n\n    /**\n     * @description\n     * A goal is an asynchronous method of work.\n     * It is a function that returns a promise.\n     * It can be used to define a unit that repeats a single promise of a step.\n     * @see AsyncWorkMethod\n     * @see WorkMethod\n     */\n    export type Goal<\n        Parent extends Scope = any,\n        Initial extends Scope = Parent,\n        Current extends Scope = Initial\n    > = AsyncWorkMethod<Parent, Initial, Current>;\n\n    /**\n     * @description\n     * A process is a synchronous procedure of work.\n     * It is a generator function that yields values and returns a final value.\n     * It can be used to define a unit that is composed of multiple steps.\n     * @see SyncWorkProcedure\n     * @see WorkProcedure\n     */\n    export type Process<\n        Parent extends Scope = any,\n        Initial extends Scope = Parent,\n        Current extends Scope = Initial\n    > = SyncWorkProcedure<Parent, Initial, Current>;\n\n    /**\n     * @description\n     * A pursuit is an asynchronous procedure of work.\n     * It is a generator function that yields promises and returns a final promise.\n     * It can be used to define a unit that is composed of multiple goals.\n     * @see AsyncWorkProcedure\n     * @see WorkProcedure\n     */\n    export type Pursuit<\n        Parent extends Scope = any,\n        Initial extends Scope = Parent,\n        Current extends Scope = Initial\n    > = AsyncWorkProcedure<Parent, Initial, Current>;\n\n    export type Of<U extends Unit> = WorkOf<U>;\n}\n// ---------------- Unit Primitives  ---------------- //\n/**\n * @description\n * The base unit interface. This is the lowest level of the unit type hierarchy.\n *  It is used to define the common properties of all units.\n */\nexport type UnitBase<\n    Parent extends Scope = any,\n    Initial extends Scope = any,\n    Current extends Scope = any\n> = {\n    type: UnitType;\n    kind: UnitKind;\n    scope: ParentScope<Parent, Initial, Current>;\n    branches: Unit.Branches<Parent, Initial, Current>;\n    work: Work<Parent, Initial, Current>;\n    next: (\n        value: Parent | Initial\n    ) => UnitFrame<Current> | PromiseLike<UnitFrame<Current>>;\n    [hasInstance]: Set<Work>;\n};\n\nexport interface AsyncUnitClass<\n    Parent extends Scope = any,\n    Initial extends Scope = any,\n    Current extends Scope = any\n> extends UnitBase<Parent, Initial, Current> {\n    type: UnitType.ASYNC;\n    future?: PromiseLike<UnitFrame<Current>>;\n    state: UnitState;\n    work: Work.Objective<Parent, Initial, Current>;\n    next: (value: Parent | Initial) => PromiseLike<UnitFrame<Current>>;\n}\n\nexport interface SyncUnitClass<\n    Parent extends Scope = any,\n    Initial extends Scope = any,\n    Current extends Scope = any\n> extends UnitBase<Parent, Initial, Current> {\n    type: UnitType.SYNC;\n    work: Work.Order<Parent, Initial, Current>;\n    next: (value: Parent | Initial) => UnitFrame<Current>;\n}\n\nexport interface ProceduralUnitClass<\n    Parent extends Scope = any,\n    Initial extends Scope = any,\n    Current extends Scope = any\n> extends UnitBase<Parent, Initial, Current> {\n    kind: UnitKind.PROCEDURAL;\n    work: Work.Procedure<Parent, Initial, Current>;\n    future?: PromiseLike<UnitFrame<Current>>;\n    state?: UnitState;\n}\n\nexport interface MethodicUnitClass<\n    Parent extends Scope = any,\n    Initial extends Scope = any,\n    Current extends Scope = any\n> extends UnitBase<Parent, Initial, Current> {\n    kind: UnitKind.METHODIC;\n    work: Work.Method<Parent, Initial, Current>;\n    state?: UnitState;\n    future?: PromiseLike<UnitFrame<Current>>;\n}\n\n/**\n * @description\n * A unit class is a unit that yields a value or a promise.\n */\nexport type UnitClass<\n    Parent extends Scope = any,\n    Initial extends Scope = any,\n    Current extends Scope = any\n> =\n    | AsyncUnitClass<Parent, Initial, Current>\n    | SyncUnitClass<Parent, Initial, Current>;\n\n/**\n * @description\n * A sync unit is a unit that yields a value.\n */\nexport type SyncUnit<\n    Parent extends Scope = any,\n    Initial extends Scope = Parent,\n    Current extends Scope = Initial\n> = SyncUnitClass<Parent, Initial, Current>;\n/**\n * @description\n * An async unit is a unit that yields a promise.\n */\nexport type AsyncUnit<\n    Parent extends Scope = any,\n    Initial extends Scope = Parent,\n    Current extends Scope = Initial\n> = AsyncUnitClass<Parent, Initial, Current>;\n\nexport type ProceduralUnit<\n    Parent extends Scope = any,\n    Initial extends Scope = Parent,\n    Current extends Scope = Initial\n> = ProceduralUnitClass<Parent, Initial, Current>;\n\nexport type MethodicUnit<\n    Parent extends Scope = any,\n    Initial extends Scope = Parent,\n    Current extends Scope = Initial\n> = MethodicUnitClass<Parent, Initial, Current>;\n\nexport type Unit<\n    Parent extends Scope = any,\n    Initial extends Scope = Parent,\n    Current extends Scope = Initial\n> =\n    | SyncUnit<Parent, Initial, Current>\n    | AsyncUnit<Parent, Initial, Current>\n    | ProceduralUnit<Parent, Initial, Current>\n    | MethodicUnit<Parent, Initial, Current>;\n\n/**\n * @description\n * A unit branch is a unit that is nested within another unit.\n * it inherits the scope of its parent unit.\n * It inherently runs when its parent unit succesfully yields a value or promise.\n * It can be either an async or sync.\n */\nexport type UnitBranch<\n    Parent extends Scope = any,\n    Initial extends Scope = Parent,\n    Current extends Scope = Initial\n> = Unit<ParentScope<Parent, Initial, Current>, any, any>;\n\n/**\n * @description\n * Unit branches are an array of unit branch.\n * It is used to define the branches of a unit.\n */\nexport type UnitBranches<\n    Parent extends Scope = any,\n    Initial extends Scope = Parent,\n    Current extends Scope = Initial\n> = UnitBranch<Parent, Initial, Current>[];\n\nexport type UnitOf<W> = W extends Work<infer P, infer I, infer C>\n    ? W extends AsyncWork<P, I, C>\n        ? Unit.Lazy<P, I, C>\n        : Unit.Eager<P, I, C>\n    : never;\nexport namespace Unit {\n    export type Interface<\n        Parent extends Scope = any,\n        Initial extends Scope = any,\n        Current extends Scope = any\n    > = UnitBase<Parent, Initial, Current>;\n    export type Class<\n        Parent extends Scope = any,\n        Initial extends Scope = any,\n        Current extends Scope = any\n    > = UnitClass<Parent, Initial, Current>;\n    /**\n     * @description\n     * alias for `UnitBranch`\n     * @see UnitBranch\n     */\n    export type Branch<\n        Parent extends Scope = any,\n        Initial extends Scope = any,\n        Current extends Scope = any\n    > = UnitBranch<Parent, Initial, Current>;\n    /**\n     * @description\n     * alias for `UnitBranches`\n     * @see UnitBranches\n     */\n    export type Branches<\n        Parent extends Scope = any,\n        Initial extends Scope = any,\n        Current extends Scope = any\n    > = UnitBranches<Parent, Initial, Current>;\n\n    /**\n     * @description\n     * A lazy unit is an async unit.\n     * It is a unit that yields a promise.\n     */\n    export type Lazy<\n        Parent extends Scope = any,\n        Initial extends Scope = any,\n        Current extends Scope = any\n    > = AsyncUnit<Parent, Initial, Current>;\n\n    /**\n     * @description\n     * An eager unit is a sync unit.\n     * It is a unit that yields a value.\n     * @see SyncUnit\n     */\n    export type Eager<\n        Parent extends Scope = any,\n        Initial extends Scope = any,\n        Current extends Scope = any\n    > = SyncUnit<Parent, Initial, Current>;\n\n    /**\n     * @description\n     * A simple unit is a methodic unit.\n     * It is a unit that yields a stable value or a promise.\n     * It is stateless.\n     * @see MethodicUnit\n     * @see Unit\n     * @see Work.Method\n     */\n    export type Simple<\n        Parent extends Scope = any,\n        Initial extends Scope = any,\n        Current extends Scope = any\n    > = MethodicUnit<Parent, Initial, Current>;\n\n    /**\n     * @description\n     * A complex unit is a procedural unit.\n     * It is a unit that yields variable values or a promises.\n     * It is stateful.\n     * @see ProceduralUnit\n     * @see Unit\n     * @see Work.Procedure\n     */\n    export type Complex<\n        Parent extends Scope = any,\n        Initial extends Scope = any,\n        Current extends Scope = any\n    > = ProceduralUnit<Parent, Initial, Current>;\n\n    /**\n     * @description\n     * A unit of a sync or async work action.\n     * @see UnitOf\n     * @see Unit\n     * @see Work\n     */\n    export type Of<W> = UnitOf<W>;\n\n    export type Type = UnitType;\n    export type Kind = UnitKind;\n}\n\nexport namespace Branch {\n    export type From<U extends Unit> = U extends Unit<infer P, infer I, infer C>\n        ? Unit.Branch<P, I, C>\n        : never;\n    export type Of<\n        U extends Unit,\n        Initial extends Scope = any,\n        Current extends Scope = Initial\n    > = U extends Unit ? Unit<ParentScope.Of<U>, Initial, Current> : never;\n}\nexport namespace Branches {\n    export type Of<U extends Unit> = U extends Unit<infer P, infer I, infer C>\n        ? Branch.From<U>[]\n        : never;\n}\n","import { AsyncFunction, MapLike, SyncFunction } from \"../../model/domain.model\";\nimport { AsyncWorkProcedure } from \"../../model/unit.model\";\n\nexport const isSync = (fn: Function): fn is SyncFunction => {\n    return fn.constructor.name === \"Function\";\n};\nexport const isAsync = (fn: Function): fn is AsyncFunction => {\n    return fn.constructor.name === \"AsyncFunction\";\n};\nexport const isGenerator = (fn: Function): fn is GeneratorFunction => {\n    return fn.constructor.name === \"GeneratorFunction\";\n};\nexport const isAsyncGenerator = (\n    fn: Function\n): fn is AsyncWorkProcedure<any, any, any> => {\n    return fn.constructor.name === \"AsyncGeneratorFunction\";\n};\nexport const isPromise = (fn: any): fn is Promise<any> => {\n    return fn.constructor.name === \"Promise\";\n};\nexport const isMap = (map: any): map is MapLike<any, any> => {\n    return typeof map?.get === \"function\" && typeof map?.set === \"function\";\n};\n","import { Scope } from \"../../model/domain.model\";\nimport { isMap } from \"../helpers/identity\";\n\nconst mapMethods = new Set([\"get\", \"set\", \"has\", \"delete\", \"clear\", \"forEach\"]);\nexport class Polytype<\n    Current extends Scope = any,\n    Prev extends any = any,\n    Next extends Scope = any\n> {\n    chain: [Prev, Current, Next] = new Array(3) as [Prev, Current, Next];\n    constructor(identity: Current, before?: Prev, after?: Next) {\n        this.chain[0] = (before || null) as Prev;\n        this.chain[1] = identity;\n        this.chain[2] = (after || null) as Next;\n        return new Proxy(this, {\n            get(target, prop) {\n                let value = Polytype.getValue(target, prop);\n                if (value) return value;\n                for (let i = 2; i > -1; i--) {\n                    let obj = target.chain[i];\n                    value = Polytype.getValue(obj, prop, i);\n                    // console.log(prop, value);\n                    if (value) return value;\n                }\n            },\n        });\n    }\n    _set(obj: Current) {\n        //comes before obj in chain\n        if (obj) {\n            this.chain[1] = obj;\n        }\n    }\n    _extend(obj: Prev) {\n        //comes after obj in chain\n        if (obj) {\n            this.chain[0] = obj;\n        }\n    }\n    _define(obj: Next) {\n        //comes  before obj in chain\n        if (obj) {\n            this.chain[2] = obj;\n        }\n    }\n    *[Symbol.iterator]() {\n        for (let obj of this.chain) {\n            yield obj;\n        }\n    }\n    static getValue(target: any, prop: any, idx: number = -1) {\n        let value;\n        if (idx == 0 && target?.ignore && target.ignore.has(prop)) {\n            return undefined;\n        } else if (\n            !Polytype.isPolytype(target) &&\n            !mapMethods.has(prop) &&\n            isMap(target)\n        ) {\n            //do this the other way around\n            value = Reflect.get(target, prop) || target.get(prop);\n        } else {\n            value = Reflect.get(target || {}, prop);\n        }\n        //do I have to do this?\n        // if (typeof value === \"function\") return value.bind(target);\n        return value;\n    }\n    static isPolytype(obj: any) {\n        return obj instanceof Polytype;\n    }\n}\nexport const polytype = <\n    Curr extends Record<any, any>,\n    Prev extends Record<any, any> = any,\n    Next extends Record<any, any> = any\n>(\n    base: Curr,\n    prev?: Prev,\n    next?: Next\n) => {\n    return new Polytype(base, prev, next) as unknown as Polytype<\n        Curr,\n        Prev,\n        Next\n    > &\n        Curr &\n        Prev &\n        Next &\n        [Prev, Curr, Next];\n};\n","import { UnitFrame } from \"../../model/unit.model\";\n\nexport const toFrame = <T>(value: T, done: boolean): UnitFrame<T> => {\n    return { value, done };\n};\n\nexport const toCompleteFrame = <T>(value: T): UnitFrame<T> => {\n    return toFrame(value, true);\n};\n","import {\n    AsyncWorkMethod,\n    UnitClass,\n    AsyncUnitClass,\n    UnitKind,\n    UnitType,\n    UnitState,\n    ParentScope,\n    Unit,\n} from \"../../model/unit.model\";\nimport { Scope } from \"../../model/domain.model\";\nimport { polytype } from \"../domain/polytype\";\nimport { toCompleteFrame } from \"../helpers/transformers\";\n\nexport const fromAsyncMethod = <\n    Parent extends Scope,\n    Initial extends Scope,\n    Current extends Scope\n>(\n    method: AsyncWorkMethod<Parent, Initial, Current>,\n    init: Initial,\n    branches: Unit<ParentScope<Parent, Initial, Current>, any, any>[]\n): AsyncUnitClass<Parent, Initial, Current> => {\n    const scope = polytype(init);\n    const onComplete = (output: Current) => {\n        duration--;\n        if (output !== undefined) {\n            scope._define(output);\n            branches.forEach((branch) => branch?.next?.(scope));\n        }\n        if (duration === 0) unit.future = undefined;\n        return toCompleteFrame(output);\n    };\n    let duration = 0;\n    const unit = {\n        type: UnitType.ASYNC,\n        kind: UnitKind.METHODIC,\n        scope,\n        branches,\n        work: method,\n        get state() {\n            return duration === 0 ? UnitState.RESOLVED : UnitState.PENDING;\n        },\n        next: (input) => {\n            duration++;\n            scope._extend(input);\n            if (unit.future) {\n                unit.future = unit.future\n                    .then(() =>\n                        method(\n                            scope,\n                            branches,\n                            unit as AsyncUnitClass<Parent, Initial, Current>\n                        )\n                    )\n                    .then(onComplete);\n            } else {\n                unit.future = method(\n                    scope,\n                    branches,\n                    unit as AsyncUnitClass<Parent, Initial, Current>\n                ).then(onComplete);\n            }\n            return unit.future;\n        },\n    } as Partial<AsyncUnitClass<Parent, Initial, Current>>;\n    duration++;\n    unit.future = method(\n        scope,\n        branches,\n        unit as AsyncUnitClass<Parent, Initial, Current>\n    ).then(onComplete);\n    return unit as AsyncUnitClass<Parent, Initial, Current>;\n};\n","import { Scope } from \"../../model/domain.model\";\nimport {\n    AsyncWorkProcedure,\n    AsyncUnit,\n    UnitKind,\n    UnitType,\n    UnitFrame,\n    UnitState,\n    ParentScope,\n    Unit,\n} from \"../../model/unit.model\";\nimport { polytype } from \"../domain/polytype\";\n\nexport const fromAsyncProcedure = <\n    Parent extends Scope,\n    Initial extends Scope,\n    Current extends Scope\n>(\n    procedure: AsyncWorkProcedure<Parent, Initial, Current>,\n    init: Initial,\n    branches: Unit<ParentScope<Parent, Initial, Current>, any, any>[]\n): AsyncUnit<Parent, Initial, Current> => {\n    const scope = polytype(init);\n    const onComplete = (\n        output: IteratorResult<Current | void, Current | void>\n    ) => {\n        duration--;\n        if (output.value !== undefined) {\n            scope._define(output.value);\n            branches.forEach((branch) => branch?.next?.(scope));\n        }\n        if (duration === 0) unit.future = undefined;\n        lastFrame = output as UnitFrame<Current>;\n        return lastFrame;\n    };\n    let duration = 0;\n    const unit = {\n        type: UnitType.ASYNC,\n        kind: UnitKind.PROCEDURAL,\n        scope,\n        branches,\n        work: procedure,\n        get state() {\n            return duration === 0 ? UnitState.RESOLVED : UnitState.PENDING;\n        },\n        next: (input) => {\n            scope._extend(input);\n            if (lastFrame.done) {\n                generator = procedure(\n                    scope,\n                    branches,\n                    unit as AsyncUnit<Parent, Initial, Current>\n                );\n            }\n            if (unit.future) {\n                unit.future = unit.future\n                    .then(() => generator.next(scope))\n                    .then(onComplete);\n            } else {\n                unit.future = generator.next(scope).then(onComplete);\n            }\n            return unit.future;\n        },\n    } as Partial<AsyncUnit<Parent, Initial, Current>>;\n    let generator = procedure(\n        scope,\n        branches,\n        unit as AsyncUnit<Parent, Initial, Current>\n    );\n    let lastFrame = {\n        value: undefined,\n        done: false,\n    } as unknown as UnitFrame<Current>;\n    unit.future = generator.next(scope).then(onComplete);\n    return unit as AsyncUnit<Parent, Initial, Current>;\n};\n","import { Scope } from \"../../model/domain.model\";\nimport {\n    SyncUnitClass,\n    UnitScope,\n    SyncWorkMethod,\n    UnitClass,\n    UnitType,\n    UnitKind,\n    SyncUnit,\n    ParentScope,\n    Unit,\n} from \"../../model/unit.model\";\nimport { polytype } from \"../domain/polytype\";\n\nexport const fromSyncMethod = <\n    Parent extends Scope,\n    Initial extends Scope,\n    Current extends Scope\n>(\n    method: SyncWorkMethod<Parent, Initial, Current>,\n    init: Initial,\n    branches: Unit<ParentScope<Parent, Initial, Current>, any, any>[]\n): SyncUnit<Parent, Initial, Current> => {\n    const scope = polytype(init);\n    const onComplete = (output: Current) => {\n        if (output !== undefined) {\n            scope._define(output);\n            branches.forEach((branch) => branch?.next?.(scope));\n        }\n        return {\n            value: output,\n            done: true,\n        };\n    };\n    const unit = {\n        type: UnitType.SYNC,\n        kind: UnitKind.METHODIC,\n        scope,\n        branches,\n        work: method,\n        next: (input) => {\n            scope._extend(input);\n            const output = method(\n                scope,\n                branches,\n                unit as SyncUnit<Parent, Initial, Current>\n            );\n            return onComplete(output);\n        },\n    } as Partial<SyncUnit<Parent, Initial, Current>>;\n    const output = method(\n        scope,\n        branches,\n        unit as SyncUnit<Parent, Initial, Current>\n    );\n    onComplete(output);\n\n    return unit as SyncUnit<Parent, Initial, Current>;\n};\n","import { Scope } from \"../../model/domain.model\";\nimport {\n    SyncWorkProcedure,\n    SyncUnitClass,\n    UnitKind,\n    UnitScope,\n    UnitClass,\n    UnitType,\n    ParentScope,\n    SyncUnit,\n    Unit,\n} from \"../../model/unit.model\";\nimport { polytype } from \"../domain/polytype\";\n\nexport const fromSyncProcedure = <\n    Parent extends Scope,\n    Initial extends Scope,\n    Current extends Scope\n>(\n    procedure: SyncWorkProcedure<Parent, Initial, Current>,\n    init: Initial,\n    branches: Unit<ParentScope<Parent, Initial, Current>, any, any>[]\n): SyncUnit<Parent, Initial, Current> => {\n    const scope = polytype(init);\n    const onComplete = (\n        output: IteratorResult<void | Current, void | Current>\n    ) => {\n        if (output.value !== undefined) {\n            scope._define(output.value);\n            branches.forEach((branch) => branch?.next?.(scope));\n        }\n        lastFrame = output;\n        return lastFrame;\n    };\n    const unit = {\n        type: UnitType.SYNC,\n        kind: UnitKind.PROCEDURAL,\n        scope,\n        branches,\n        work: procedure,\n        next: (input) => {\n            scope._extend(input);\n            if (lastFrame.done) {\n                generator = procedure(\n                    scope,\n                    branches,\n                    unit as SyncUnit<Parent, Initial, Current>\n                );\n            }\n            const output = generator.next(scope);\n            onComplete(output);\n            return output;\n        },\n    } as Partial<SyncUnitClass<Parent, Initial, Current>>;\n    let generator = procedure(\n        scope,\n        branches,\n        unit as SyncUnit<Parent, Initial, Current>\n    );\n    let lastFrame = generator.next(scope);\n    onComplete(lastFrame);\n    return unit as SyncUnit<Parent, Initial, Current>;\n};\n","import { Primitive, Scope } from \"../../model/domain.model\";\nimport {\n    UnitScope,\n    UnitClass,\n    UnitType,\n    UnitKind,\n    Work,\n    Unit,\n    AsyncUnit,\n    ParentScope,\n} from \"../../model/unit.model\";\nimport { polytype } from \"../domain/polytype\";\nimport { createUnit } from \"../index\";\n\nconst reassignUnit = (unit: Unit, newUnit: Unit): void => {\n    unit.kind = newUnit.kind;\n    if (unit.type === UnitType.ASYNC)\n        unit.future = (newUnit as AsyncUnit).future;\n};\nexport const fromKey = <\n    Parent extends Scope,\n    Initial extends Scope,\n    Current extends Scope\n>(\n    key: Primitive,\n    init: Initial,\n    branches: Unit<ParentScope<Parent, Initial, Current>, any, any>[]\n): Unit<Parent, Initial, Current> => {\n    let parentUnit: Unit<Parent, Initial, Current>;\n    let unit: UnitClass;\n    let scheme = () => {};\n    const getScheme = (props: any) => {\n        if (typeof props[key as keyof typeof props] === \"function\") {\n            return props[key as keyof typeof props];\n        }\n        return scheme;\n    };\n    let procedure = function* (props: Initial, branches: any[], unit: any) {\n        (<any>props).tag = key;\n        unit = createUnit(scheme as any, props, ...branches);\n        let [, init, output] = unit.scope;\n        while (true) {\n            const result = (yield output) as UnitScope<\n                Parent,\n                Initial,\n                Current\n            >;\n            let currentScheme = getScheme(result);\n            if (!Object.is(currentScheme, scheme)) {\n                scheme = currentScheme;\n                unit = createUnit(scheme as any, props, ...branches);\n                reassignUnit(parentUnit as Unit, unit);\n            } else {\n                unit?.next(result);\n            }\n            output = unit.scope.chain[2];\n        }\n    } as unknown as Work<Parent, Initial, Current>;\n    return (parentUnit = createUnit(procedure as any, init, ...branches));\n};\n\nexport const fromKeyAsync = <\n    Parent extends Scope,\n    Initial extends Scope,\n    Current extends Scope\n>(\n    key: Primitive,\n    init: Initial,\n    branches: Unit<ParentScope<Parent, Initial, Current>, any, any>[]\n): Unit<Parent, Initial, Current> => {\n    let parentUnit: Unit<Parent, Initial, Current>;\n    let unit: Unit;\n    let scheme = () => {};\n    const getScheme = (props: any) => {\n        if (typeof props[key as keyof typeof props] === \"function\") {\n            return props[key as keyof typeof props];\n        }\n        return scheme;\n    };\n    let procedure = async function* (\n        props: Initial,\n        branches: any[],\n        unit: any\n    ) {\n        unit = createUnit(scheme as any, props, ...branches);\n        await unit.future;\n        let [, init, output] = unit.scope;\n        while (true) {\n            const result = (yield output) as UnitScope<\n                Parent,\n                Initial,\n                Current\n            >;\n            let currentScheme = getScheme(result);\n            if (!Object.is(currentScheme, scheme)) {\n                scheme = currentScheme;\n                unit = createUnit(scheme as any, props, ...branches);\n                reassignUnit(parentUnit as Unit, unit);\n                await unit.future;\n            } else {\n                await unit?.next(result);\n            }\n            output = unit.scope.chain[2];\n        }\n    } as unknown as Work<Parent, Initial, Current>;\n    return (parentUnit = createUnit(procedure as any, init, ...branches));\n};\n","import { Unit, Work } from \"../../model/unit.model\";\nimport {\n    fromAsyncProcedure,\n    fromSyncProcedure,\n    fromAsyncMethod,\n    fromSyncMethod,\n    fromKey,\n    fromKeyAsync,\n} from \"../adapters/index\";\nimport { Primitive, Scope } from \"../../model/domain.model\";\nimport { isAsync, isAsyncGenerator, isGenerator } from \"../helpers/identity\";\n\nexport const createUnit = <\n    Parent extends Scope = any,\n    Initial extends Scope = any,\n    Current extends Scope = any\n>(\n    method: Work<Parent, Initial, Current> | Primitive,\n    init: Initial,\n    ...branches: Unit.Branches<Parent, Initial, Current>\n): Unit<Parent, Initial, Current> => {\n    if (typeof method !== \"function\") {\n        if ((init as any)?.await) {\n            return fromKeyAsync(method, init, branches);\n        }\n        return fromKey(method, init, branches);\n    } else if (isAsyncGenerator(method)) {\n        return fromAsyncProcedure(\n            method as Work.Pursuit<Parent, Initial, Current>,\n            init,\n            branches\n        );\n    } else if (isGenerator(method)) {\n        return fromSyncProcedure(\n            method as Work.Process<Parent, Initial, Current>,\n            init,\n            branches\n        );\n    } else if (isAsync(method)) {\n        return fromAsyncMethod(\n            method as Work.Goal<Parent, Initial, Current>,\n            init,\n            branches\n        );\n    } else {\n        return fromSyncMethod(\n            method as Work.Step<Parent, Initial, Current>,\n            init,\n            branches\n        ) as Unit<Parent, Initial, Current>;\n    }\n};\n","export const NOOP = Symbol.for(\"NOOP\");\nexport const noop = NOOP;\nexport const hasInstance = Symbol(\"hasInstance\");\n","import { Scope } from \"../../../model/domain.model\";\n\nexport const isPlacement = (props: any): props is { place: string } => {\n    return props.place && typeof props.place === \"string\";\n};\nexport const hasId = (props: any): props is { id: string } => {\n    return props.id && typeof props.id === \"string\";\n};\n\nlet index = 0;\nexport const getIndex = (): number => {\n    return index++;\n};\n\nexport const convertCSSToPx = (value: string | number): string => {\n    if (typeof value === \"number\") {\n        return `${value}px`;\n    }\n    return value;\n};\n\nexport const convertHtmlProp = (prop: string): string => {\n    if (prop == \"className\") return \"class\";\n    return prop.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`);\n};\n","export const htmlEvents = [\n    \"click\",\n    \"resize\",\n    \"scroll\",\n    \"contextmenu\",\n    \"dblclick\",\n    \"mousedown\",\n    \"mouseenter\",\n    \"mouseleave\",\n    \"mousemove\",\n    \"mouseout\",\n    \"mouseover\",\n    \"mouseup\",\n    \"wheel\",\n    \"keydown\",\n    \"keypress\",\n    \"keyup\",\n    \"abort\",\n    \"afterprint\",\n    \"beforeprint\",\n    \"beforeunload\",\n    \"error\",\n    \"hashchange\",\n    \"load\",\n    \"pageshow\",\n    \"pagehide\",\n    \"popstate\",\n    \"resize\",\n    \"storage\",\n    \"unload\",\n    \"blur\",\n    \"change\",\n    \"focus\",\n    \"focusin\",\n    \"focusout\",\n    \"input\",\n    \"invalid\",\n    \"reset\",\n    \"search\",\n    \"select\",\n    \"submit\",\n    \"drag\",\n    \"dragend\",\n    \"dragenter\",\n    \"dragleave\",\n    \"dragover\",\n    \"dragstart\",\n    \"drop\",\n    \"copy\",\n    \"cut\",\n    \"paste\",\n    \"abort\",\n    \"canplay\",\n    \"canplaythrough\",\n    \"durationchange\",\n    \"emptied\",\n    \"ended\",\n    \"error\",\n    \"loadeddata\",\n    \"loadedmetadata\",\n    \"loadstart\",\n    \"pause\",\n    \"play\",\n    \"playing\",\n    \"progress\",\n    \"ratechange\",\n    \"seeked\",\n    \"seeking\",\n    \"stalled\",\n    \"suspend\",\n    \"timeupdate\",\n    \"volumechange\",\n    \"waiting\",\n    \"show\",\n    \"toggle\",\n    \"wheel\",\n    \"load\",\n    \"error\",\n    \"abort\",\n] as const;\n\nexport const htmlEventHandlers = htmlEvents.map(\n    (event) => `on${event[0].toUpperCase()}${event.slice(1)}`\n);\n","class CaseInsensitiveSet extends Set {\n    constructor(values: Iterable<string>) {\n        super(Array.from(values, (it) => it.toLowerCase()));\n    }\n\n    add(str: string) {\n        return super.add(str.toLowerCase());\n    }\n\n    has(str: string) {\n        return super.has(str.toLowerCase());\n    }\n\n    delete(str: string) {\n        return super.delete(str.toLowerCase());\n    }\n}\nexport const htmlTags = new CaseInsensitiveSet(\n    `a,abbr,acronym,abbr,address,applet,embed,object,area,article\n,aside,audio,b,base,basefont,bdi,bdo,big,blockquote,body,br,button,canvas,caption,center,cite\n,code,col,colgroup,data,datalist,dd,del,details,dfn,dialog,dir,ul,div,dl,dt,em,embed,fieldset\n,figcaption,figure,font,footer,form,frame,frameset,h1 to <h6>,head,header,hr,html,i,iframe,img\n,input,ins,kbd,label,legend,li,link,main,map,mark,meta,meter,nav,noframes,noscript,object,ol\n,optgroup,option,output,p,param,picture,pre,progress,q,rp,rt,ruby,s,samp,script,section,select\n,small,source,span,strike,del,s,strong,style,sub,summary,sup,svg,table,tbody,td,template,textarea\n,tfoot,th,thead,time,title,tr,track,tt,u,ul,var,video,wbr`.split(\",\")\n);\n","import { MapLike, Scope, KeyedScope } from \"../../../model/domain.model\";\nimport {\n    ParentScope,\n    SyncUnit,\n    Unit,\n    UnitClass,\n    UnitScope,\n} from \"../../../model/unit.model\";\nimport {\n    convertCSSToPx,\n    convertHtmlProp,\n    getIndex,\n    hasId,\n    isPlacement,\n} from \"./helpers\";\nimport { htmlEventHandlers, htmlEvents } from \"./htmlEvents\";\nimport { htmlTags } from \"./htmlTags\";\n\n// ------------------ Html Types ------------------\ntype HtmlTags = keyof HTMLElementTagNameMap;\ntype HtmlInput = KeyedScope<\n    (\n        | {\n              use: HtmlTags;\n              id?: string | number;\n              place?: never;\n          }\n        | {\n              use?: never;\n              place: string;\n          }\n    ) & {\n        event?: string;\n    }\n>;\ninterface IHtmlOutput extends JSX.UnitElement {\n    root: HTMLElement;\n    container: HTMLElement;\n    children: Map<HTMLElement, Unit>;\n    child: Map<string, Unit<HtmlOutput, HtmlOutput, HtmlOutput>>;\n    remove: (id: Unit | string) => boolean;\n    trigger: (event: string, payload?: any) => void;\n    restyle: (\n        style: Partial<JSX.CSSProperties<string | number, number>>\n    ) => void;\n    change: (props: Partial<JSX.UnitElement>) => void;\n    ignore: Set<string>;\n    id: string;\n    type?: string;\n    payload?: any;\n}\nexport type HtmlOutput = IHtmlOutput &\n    MapLike<HtmlTags, Unit<Scope, Scope, IHtmlOutput>>;\ntype HtmlProps = UnitScope<HtmlInput, HtmlInput, HtmlOutput>;\n\nconst resolveSelector = (\n    children: Map<string, Unit>,\n    selector: Unit<any> | string\n): [unit: Unit | undefined, id: string] => {\n    let unit: Unit | undefined;\n    let id: string;\n    switch (typeof selector) {\n        case \"string\":\n            id = selector;\n            unit = children.get(selector);\n            break;\n        case \"object\":\n            unit = selector;\n            id = unit.scope.id;\n            break;\n    }\n    return [unit, id];\n};\n\n// ------------------ Html Element Unit ------------------\nconst createElement = function* (\n    props: HtmlProps,\n    branches: any[],\n    self: UnitClass\n) {\n    const child = document.createElement(props.tag!);\n    child.id = props.id;\n    let output: Scope | undefined = {\n        container: child,\n    };\n    if (props.id) {\n        props.child.set(props.id, self);\n    }\n    if (props.style) {\n        props.restyle.call(output, props.style);\n    }\n    props.children.set(child, self);\n    props.container.appendChild(child);\n    while (true) {\n        const frame = (yield output) as unknown as HtmlProps;\n        if (frame.type === \"event\") {\n            // console.log(\"child\", frame.event, props.id);\n            props[`on${frame.event!}` as keyof HtmlOutput]?.(\n                frame.payload,\n                child\n            );\n        }\n        if (frame.type === \"update\") {\n            props.onUpdate?.(frame.payload, self);\n        }\n        output = undefined;\n    }\n};\n\n// ------------------ Html Unit ------------------\n/**\n * @description\n * Html is a unit that can be used to create a context for html elements.\n * @param props - The props of the unit.\n * @param branches - The branches of the unit.\n * @param self - The unit itself.\n * @returns\n * @example\n * <Html use=\"div\" id=\"some-div\">\n * <Html place=\"#some-id\">\n * <Html use=\"main\">\n *      <div id=\"some-div\"></div>\n * </Html>\n */\nexport const Html = (\n    props: HtmlInput,\n    branches: SyncUnit<{ id: string }>[],\n    self: SyncUnit<HtmlInput, HtmlInput, HtmlOutput>\n) => {\n    const root = isPlacement(props)\n        ? document.querySelector(props.place)!\n        : document.createElement(props.use);\n    root.id = `root-${getIndex()}${hasId(props) ? ` ${props.id}` : \"\"}`;\n    const children = new Map();\n    const child = new Map();\n    htmlEvents.forEach((event) => {\n        root.addEventListener(event, (e) => {\n            const child = ((e as CustomEvent).detail?.target ||\n                e.target) as HTMLElement;\n            const unit = children.get(child);\n            const type = \"event\";\n            const eventType = e.type[0].toUpperCase() + e.type.slice(1);\n            // console.log(\"container\", eventType, child.id);\n            unit?.next?.({ type, event: eventType, payload: e });\n        });\n    });\n    return {\n        root,\n        container: root,\n        children,\n        child,\n        remove(selector?: Unit | string) {\n            let element: any, id: string;\n            if (selector) {\n                let [unit, newId] = resolveSelector(child, selector);\n                id = newId;\n                element = unit?.scope.container;\n                unit?.scope.trigger(\"remove\");\n            } else {\n                element = this.container;\n                id = this.id;\n                this.trigger(\"remove\");\n            }\n            if (element) {\n                children.delete(element);\n                child.delete(id);\n                element.remove();\n                return true;\n            }\n            return false;\n        },\n        trigger(event: string, payload?: any) {\n            this.container.dispatchEvent(\n                new CustomEvent(event, {\n                    detail: payload,\n                    bubbles: true,\n                })\n            );\n        },\n        change(props: Partial<JSX.UnitElement>) {\n            Object.entries(props).forEach(([key, value]) => {\n                if (key == \"style\") {\n                    this.restyle(value as any);\n                } else {\n                    this.container.setAttribute(\n                        convertHtmlProp(key),\n                        value as any\n                    );\n                }\n            });\n            this.children.get(this.container)?.next?.({\n                type: \"update\",\n                payload: new CustomEvent(\"update\", {\n                    detail: props,\n                    bubbles: true,\n                }),\n            });\n        },\n        restyle(style: Partial<JSX.CSSProperties<string | number, number>>) {\n            Object.entries(style).forEach(([key, value]) => {\n                this.container.style.setProperty(\n                    convertHtmlProp(key),\n                    convertCSSToPx(value)\n                );\n            });\n        },\n        get(key) {\n            if (typeof key == \"string\" && htmlTags.has(key))\n                return createElement;\n        },\n        set(key, value) {},\n        ignore: new Set([\"id\", \"style\", ...htmlEventHandlers]),\n    } as HtmlOutput;\n};\n\nexport type HtmlUnit = Unit.Eager<HtmlInput, HtmlInput, HtmlOutput>;\nexport type HtmlChildUnit<\n    I extends Scope = any,\n    C extends Scope = I\n> = Unit.Eager<Partial<ParentScope.Of<HtmlUnit>>, I, C>;\n\nexport namespace Html {\n    export type Unit = HtmlUnit;\n    export type Child<\n        I extends Scope = any,\n        C extends Scope = I\n    > = HtmlChildUnit<I, C>;\n    export type Children<\n        I extends Scope = any,\n        C extends Scope = I\n    > = HtmlChildUnit<I, C>[];\n}\n"],"names":["UnitType","UnitState","UnitKind","output","branches","unit","init","child","props"],"mappings":"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"}